type AggregateAnswer {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregatePrompt {
  count: Int!
}

type AggregateResponse {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTerm {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Answer {
  id: ID!
  text: String!
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  text: String!
}

input AnswerCreateManyInput {
  create: [AnswerCreateInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateOneInput {
  create: AnswerCreateInput
  connect: AnswerWhereUniqueInput
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type AnswerPreviousValues {
  id: ID!
  text: String!
}

input AnswerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateDataInput {
  text: String
}

input AnswerUpdateInput {
  text: String
}

input AnswerUpdateManyDataInput {
  text: String
}

input AnswerUpdateManyInput {
  create: [AnswerCreateInput!]
  update: [AnswerUpdateWithWhereUniqueNestedInput!]
  upsert: [AnswerUpsertWithWhereUniqueNestedInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyMutationInput {
  text: String
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerUpdateOneInput {
  create: AnswerCreateInput
  update: AnswerUpdateDataInput
  upsert: AnswerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AnswerWhereUniqueInput
}

input AnswerUpdateWithWhereUniqueNestedInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateDataInput!
}

input AnswerUpsertNestedInput {
  update: AnswerUpdateDataInput!
  create: AnswerCreateInput!
}

input AnswerUpsertWithWhereUniqueNestedInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateDataInput!
  create: AnswerCreateInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  name: String!
  students(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  teachers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  term: Term!
  code: String!
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  teachers: UserCreateManyWithoutCoursesTeachingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
}

input CourseCreateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutTermInput {
  create: [CourseCreateWithoutTermInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneInput {
  create: CourseCreateInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutStudentsInput {
  id: ID
  name: String!
  teachers: UserCreateManyWithoutCoursesTeachingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
}

input CourseCreateWithoutTeachersInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
}

input CourseCreateWithoutTermInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  teachers: UserCreateManyWithoutCoursesTeachingInput
  code: String!
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  code: String!
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
}

input CourseUpdateInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
}

input CourseUpdateManyDataInput {
  name: String
  code: String
}

input CourseUpdateManyMutationInput {
  name: String
  code: String
}

input CourseUpdateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutStudentsInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutStudentsInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutTermInput {
  create: [CourseCreateWithoutTermInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTermInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTermInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredInput {
  create: CourseCreateInput
  update: CourseUpdateDataInput
  upsert: CourseUpsertNestedInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutStudentsDataInput {
  name: String
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
}

input CourseUpdateWithoutTeachersDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
}

input CourseUpdateWithoutTermDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  code: String
}

input CourseUpdateWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutStudentsDataInput!
}

input CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTeachersDataInput!
}

input CourseUpdateWithWhereUniqueWithoutTermInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTermDataInput!
}

input CourseUpsertNestedInput {
  update: CourseUpdateDataInput!
  create: CourseCreateInput!
}

input CourseUpsertWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutStudentsDataInput!
  create: CourseCreateWithoutStudentsInput!
}

input CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTeachersDataInput!
  create: CourseCreateWithoutTeachersInput!
}

input CourseUpsertWithWhereUniqueWithoutTermInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTermDataInput!
  create: CourseCreateWithoutTermInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  students_every: UserWhereInput
  students_some: UserWhereInput
  students_none: UserWhereInput
  teachers_every: UserWhereInput
  teachers_some: UserWhereInput
  teachers_none: UserWhereInput
  term: TermWhereInput
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
  code: String
}

scalar DateTime

scalar Long

type Mutation {
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(where: AnswerWhereUniqueInput!, create: AnswerCreateInput!, update: AnswerUpdateInput!): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createPrompt(data: PromptCreateInput!): Prompt!
  updatePrompt(data: PromptUpdateInput!, where: PromptWhereUniqueInput!): Prompt
  updateManyPrompts(data: PromptUpdateManyMutationInput!, where: PromptWhereInput): BatchPayload!
  upsertPrompt(where: PromptWhereUniqueInput!, create: PromptCreateInput!, update: PromptUpdateInput!): Prompt!
  deletePrompt(where: PromptWhereUniqueInput!): Prompt
  deleteManyPrompts(where: PromptWhereInput): BatchPayload!
  createResponse(data: ResponseCreateInput!): Response!
  updateResponse(data: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response
  upsertResponse(where: ResponseWhereUniqueInput!, create: ResponseCreateInput!, update: ResponseUpdateInput!): Response!
  deleteResponse(where: ResponseWhereUniqueInput!): Response
  deleteManyResponses(where: ResponseWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTerm(data: TermCreateInput!): Term!
  updateTerm(data: TermUpdateInput!, where: TermWhereUniqueInput!): Term
  updateManyTerms(data: TermUpdateManyMutationInput!, where: TermWhereInput): BatchPayload!
  upsertTerm(where: TermWhereUniqueInput!, create: TermCreateInput!, update: TermUpdateInput!): Term!
  deleteTerm(where: TermWhereUniqueInput!): Term
  deleteManyTerms(where: TermWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Prompt {
  id: ID!
  text: String!
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
}

type PromptConnection {
  pageInfo: PageInfo!
  edges: [PromptEdge]!
  aggregate: AggregatePrompt!
}

input PromptCreateInput {
  id: ID
  text: String!
  answers: AnswerCreateManyInput
}

input PromptCreateManyInput {
  create: [PromptCreateInput!]
  connect: [PromptWhereUniqueInput!]
}

input PromptCreateOneInput {
  create: PromptCreateInput
  connect: PromptWhereUniqueInput
}

type PromptEdge {
  node: Prompt!
  cursor: String!
}

enum PromptOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type PromptPreviousValues {
  id: ID!
  text: String!
}

input PromptScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [PromptScalarWhereInput!]
  OR: [PromptScalarWhereInput!]
  NOT: [PromptScalarWhereInput!]
}

type PromptSubscriptionPayload {
  mutation: MutationType!
  node: Prompt
  updatedFields: [String!]
  previousValues: PromptPreviousValues
}

input PromptSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PromptWhereInput
  AND: [PromptSubscriptionWhereInput!]
  OR: [PromptSubscriptionWhereInput!]
  NOT: [PromptSubscriptionWhereInput!]
}

input PromptUpdateDataInput {
  text: String
  answers: AnswerUpdateManyInput
}

input PromptUpdateInput {
  text: String
  answers: AnswerUpdateManyInput
}

input PromptUpdateManyDataInput {
  text: String
}

input PromptUpdateManyInput {
  create: [PromptCreateInput!]
  update: [PromptUpdateWithWhereUniqueNestedInput!]
  upsert: [PromptUpsertWithWhereUniqueNestedInput!]
  delete: [PromptWhereUniqueInput!]
  connect: [PromptWhereUniqueInput!]
  set: [PromptWhereUniqueInput!]
  disconnect: [PromptWhereUniqueInput!]
  deleteMany: [PromptScalarWhereInput!]
  updateMany: [PromptUpdateManyWithWhereNestedInput!]
}

input PromptUpdateManyMutationInput {
  text: String
}

input PromptUpdateManyWithWhereNestedInput {
  where: PromptScalarWhereInput!
  data: PromptUpdateManyDataInput!
}

input PromptUpdateOneInput {
  create: PromptCreateInput
  update: PromptUpdateDataInput
  upsert: PromptUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PromptWhereUniqueInput
}

input PromptUpdateWithWhereUniqueNestedInput {
  where: PromptWhereUniqueInput!
  data: PromptUpdateDataInput!
}

input PromptUpsertNestedInput {
  update: PromptUpdateDataInput!
  create: PromptCreateInput!
}

input PromptUpsertWithWhereUniqueNestedInput {
  where: PromptWhereUniqueInput!
  update: PromptUpdateDataInput!
  create: PromptCreateInput!
}

input PromptWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  AND: [PromptWhereInput!]
  OR: [PromptWhereInput!]
  NOT: [PromptWhereInput!]
}

input PromptWhereUniqueInput {
  id: ID
}

type Query {
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer]!
  answersConnection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnswerConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  prompt(where: PromptWhereUniqueInput!): Prompt
  prompts(where: PromptWhereInput, orderBy: PromptOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prompt]!
  promptsConnection(where: PromptWhereInput, orderBy: PromptOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PromptConnection!
  response(where: ResponseWhereUniqueInput!): Response
  responses(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Response]!
  responsesConnection(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResponseConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  term(where: TermWhereUniqueInput!): Term
  terms(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Term]!
  termsConnection(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TermConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Response {
  id: ID!
  student: User
  prompt: Prompt
  answer: Answer
  session: Session
  createdAt: DateTime!
}

type ResponseConnection {
  pageInfo: PageInfo!
  edges: [ResponseEdge]!
  aggregate: AggregateResponse!
}

input ResponseCreateInput {
  id: ID
  student: UserCreateOneInput
  prompt: PromptCreateOneInput
  answer: AnswerCreateOneInput
  session: SessionCreateOneInput
}

type ResponseEdge {
  node: Response!
  cursor: String!
}

enum ResponseOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type ResponsePreviousValues {
  id: ID!
  createdAt: DateTime!
}

type ResponseSubscriptionPayload {
  mutation: MutationType!
  node: Response
  updatedFields: [String!]
  previousValues: ResponsePreviousValues
}

input ResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResponseWhereInput
  AND: [ResponseSubscriptionWhereInput!]
  OR: [ResponseSubscriptionWhereInput!]
  NOT: [ResponseSubscriptionWhereInput!]
}

input ResponseUpdateInput {
  student: UserUpdateOneInput
  prompt: PromptUpdateOneInput
  answer: AnswerUpdateOneInput
  session: SessionUpdateOneInput
}

input ResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: UserWhereInput
  prompt: PromptWhereInput
  answer: AnswerWhereInput
  session: SessionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  NOT: [ResponseWhereInput!]
}

input ResponseWhereUniqueInput {
  id: ID
}

enum Role {
  Student
  Teacher
}

type Session {
  id: ID!
  startsAt: DateTime!
  endsAt: DateTime!
  course: Course!
  prompts(where: PromptWhereInput, orderBy: PromptOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prompt!]
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  startsAt: DateTime!
  endsAt: DateTime!
  course: CourseCreateOneInput!
  prompts: PromptCreateManyInput
}

input SessionCreateOneInput {
  create: SessionCreateInput
  connect: SessionWhereUniqueInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  startsAt_ASC
  startsAt_DESC
  endsAt_ASC
  endsAt_DESC
}

type SessionPreviousValues {
  id: ID!
  startsAt: DateTime!
  endsAt: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateDataInput {
  startsAt: DateTime
  endsAt: DateTime
  course: CourseUpdateOneRequiredInput
  prompts: PromptUpdateManyInput
}

input SessionUpdateInput {
  startsAt: DateTime
  endsAt: DateTime
  course: CourseUpdateOneRequiredInput
  prompts: PromptUpdateManyInput
}

input SessionUpdateManyMutationInput {
  startsAt: DateTime
  endsAt: DateTime
}

input SessionUpdateOneInput {
  create: SessionCreateInput
  update: SessionUpdateDataInput
  upsert: SessionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SessionWhereUniqueInput
}

input SessionUpsertNestedInput {
  update: SessionUpdateDataInput!
  create: SessionCreateInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  course: CourseWhereInput
  prompts_every: PromptWhereInput
  prompts_some: PromptWhereInput
  prompts_none: PromptWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  prompt(where: PromptSubscriptionWhereInput): PromptSubscriptionPayload
  response(where: ResponseSubscriptionWhereInput): ResponseSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  term(where: TermSubscriptionWhereInput): TermSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Term {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  name: String!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type TermConnection {
  pageInfo: PageInfo!
  edges: [TermEdge]!
  aggregate: AggregateTerm!
}

input TermCreateInput {
  id: ID
  startDate: DateTime!
  endDate: DateTime!
  name: String!
  courses: CourseCreateManyWithoutTermInput
}

input TermCreateOneWithoutCoursesInput {
  create: TermCreateWithoutCoursesInput
  connect: TermWhereUniqueInput
}

input TermCreateWithoutCoursesInput {
  id: ID
  startDate: DateTime!
  endDate: DateTime!
  name: String!
}

type TermEdge {
  node: Term!
  cursor: String!
}

enum TermOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  name_ASC
  name_DESC
}

type TermPreviousValues {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  name: String!
}

type TermSubscriptionPayload {
  mutation: MutationType!
  node: Term
  updatedFields: [String!]
  previousValues: TermPreviousValues
}

input TermSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TermWhereInput
  AND: [TermSubscriptionWhereInput!]
  OR: [TermSubscriptionWhereInput!]
  NOT: [TermSubscriptionWhereInput!]
}

input TermUpdateInput {
  startDate: DateTime
  endDate: DateTime
  name: String
  courses: CourseUpdateManyWithoutTermInput
}

input TermUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
  name: String
}

input TermUpdateOneRequiredWithoutCoursesInput {
  create: TermCreateWithoutCoursesInput
  update: TermUpdateWithoutCoursesDataInput
  upsert: TermUpsertWithoutCoursesInput
  connect: TermWhereUniqueInput
}

input TermUpdateWithoutCoursesDataInput {
  startDate: DateTime
  endDate: DateTime
  name: String
}

input TermUpsertWithoutCoursesInput {
  update: TermUpdateWithoutCoursesDataInput!
  create: TermCreateWithoutCoursesInput!
}

input TermWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [TermWhereInput!]
  OR: [TermWhereInput!]
  NOT: [TermWhereInput!]
}

input TermWhereUniqueInput {
  id: ID
  name: String
}

type User {
  id: ID!
  username: String!
  name: String!
  password: String!
  coursesAttending(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  coursesTeaching(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  role: Role!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesAttending: CourseCreateManyWithoutStudentsInput
  coursesTeaching: CourseCreateManyWithoutTeachersInput
  role: Role
}

input UserCreateManyWithoutCoursesAttendingInput {
  create: [UserCreateWithoutCoursesAttendingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutCoursesTeachingInput {
  create: [UserCreateWithoutCoursesTeachingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCoursesAttendingInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesTeaching: CourseCreateManyWithoutTeachersInput
  role: Role
}

input UserCreateWithoutCoursesTeachingInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesAttending: CourseCreateManyWithoutStudentsInput
  role: Role
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  name: String!
  password: String!
  role: Role!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateManyDataInput {
  username: String
  name: String
  password: String
  role: Role
}

input UserUpdateManyMutationInput {
  username: String
  name: String
  password: String
  role: Role
}

input UserUpdateManyWithoutCoursesAttendingInput {
  create: [UserCreateWithoutCoursesAttendingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCoursesAttendingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCoursesAttendingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutCoursesTeachingInput {
  create: [UserCreateWithoutCoursesTeachingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCoursesTeachingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCoursesTeachingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCoursesAttendingDataInput {
  username: String
  name: String
  password: String
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateWithoutCoursesTeachingDataInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  role: Role
}

input UserUpdateWithWhereUniqueWithoutCoursesAttendingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCoursesAttendingDataInput!
}

input UserUpdateWithWhereUniqueWithoutCoursesTeachingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCoursesTeachingDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutCoursesAttendingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCoursesAttendingDataInput!
  create: UserCreateWithoutCoursesAttendingInput!
}

input UserUpsertWithWhereUniqueWithoutCoursesTeachingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCoursesTeachingDataInput!
  create: UserCreateWithoutCoursesTeachingInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  coursesAttending_every: CourseWhereInput
  coursesAttending_some: CourseWhereInput
  coursesAttending_none: CourseWhereInput
  coursesTeaching_every: CourseWhereInput
  coursesTeaching_some: CourseWhereInput
  coursesTeaching_none: CourseWhereInput
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}

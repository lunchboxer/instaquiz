module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAnswer {
  count: Int!
}

type AggregateCourse {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateResponse {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateTerm {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Answer {
  id: ID!
  text: String!
  question: Question!
  responses(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Response!]
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  text: String!
  question: QuestionCreateOneWithoutAnswersInput!
  responses: ResponseCreateManyWithoutAnswerInput
}

input AnswerCreateManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateOneWithoutResponsesInput {
  create: AnswerCreateWithoutResponsesInput
  connect: AnswerWhereUniqueInput
}

input AnswerCreateWithoutQuestionInput {
  id: ID
  text: String!
  responses: ResponseCreateManyWithoutAnswerInput
}

input AnswerCreateWithoutResponsesInput {
  id: ID
  text: String!
  question: QuestionCreateOneWithoutAnswersInput!
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
}

type AnswerPreviousValues {
  id: ID!
  text: String!
}

input AnswerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateInput {
  text: String
  question: QuestionUpdateOneRequiredWithoutAnswersInput
  responses: ResponseUpdateManyWithoutAnswerInput
}

input AnswerUpdateManyDataInput {
  text: String
}

input AnswerUpdateManyMutationInput {
  text: String
}

input AnswerUpdateManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerUpdateOneRequiredWithoutResponsesInput {
  create: AnswerCreateWithoutResponsesInput
  update: AnswerUpdateWithoutResponsesDataInput
  upsert: AnswerUpsertWithoutResponsesInput
  connect: AnswerWhereUniqueInput
}

input AnswerUpdateWithoutQuestionDataInput {
  text: String
  responses: ResponseUpdateManyWithoutAnswerInput
}

input AnswerUpdateWithoutResponsesDataInput {
  text: String
  question: QuestionUpdateOneRequiredWithoutAnswersInput
}

input AnswerUpdateWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutQuestionDataInput!
}

input AnswerUpsertWithoutResponsesInput {
  update: AnswerUpdateWithoutResponsesDataInput!
  create: AnswerCreateWithoutResponsesInput!
}

input AnswerUpsertWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutQuestionDataInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  question: QuestionWhereInput
  responses_every: ResponseWhereInput
  responses_some: ResponseWhereInput
  responses_none: ResponseWhereInput
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  name: String!
  students(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  teachers(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  term: Term!
  code: String!
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session!]
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  teachers: UserCreateManyWithoutCoursesTeachingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
  sessions: SessionCreateManyWithoutCourseInput
}

input CourseCreateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutTermInput {
  create: [CourseCreateWithoutTermInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneWithoutSessionsInput {
  create: CourseCreateWithoutSessionsInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutSessionsInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  teachers: UserCreateManyWithoutCoursesTeachingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
}

input CourseCreateWithoutStudentsInput {
  id: ID
  name: String!
  teachers: UserCreateManyWithoutCoursesTeachingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
  sessions: SessionCreateManyWithoutCourseInput
}

input CourseCreateWithoutTeachersInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  term: TermCreateOneWithoutCoursesInput!
  code: String!
  sessions: SessionCreateManyWithoutCourseInput
}

input CourseCreateWithoutTermInput {
  id: ID
  name: String!
  students: UserCreateManyWithoutCoursesAttendingInput
  teachers: UserCreateManyWithoutCoursesTeachingInput
  code: String!
  sessions: SessionCreateManyWithoutCourseInput
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  code: String!
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
  sessions: SessionUpdateManyWithoutCourseInput
}

input CourseUpdateManyDataInput {
  name: String
  code: String
}

input CourseUpdateManyMutationInput {
  name: String
  code: String
}

input CourseUpdateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutStudentsInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutStudentsInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutTeachersInput {
  create: [CourseCreateWithoutTeachersInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeachersInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeachersInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutTermInput {
  create: [CourseCreateWithoutTermInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTermInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTermInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredWithoutSessionsInput {
  create: CourseCreateWithoutSessionsInput
  update: CourseUpdateWithoutSessionsDataInput
  upsert: CourseUpsertWithoutSessionsInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutSessionsDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
}

input CourseUpdateWithoutStudentsDataInput {
  name: String
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
  sessions: SessionUpdateManyWithoutCourseInput
}

input CourseUpdateWithoutTeachersDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  term: TermUpdateOneRequiredWithoutCoursesInput
  code: String
  sessions: SessionUpdateManyWithoutCourseInput
}

input CourseUpdateWithoutTermDataInput {
  name: String
  students: UserUpdateManyWithoutCoursesAttendingInput
  teachers: UserUpdateManyWithoutCoursesTeachingInput
  code: String
  sessions: SessionUpdateManyWithoutCourseInput
}

input CourseUpdateWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutStudentsDataInput!
}

input CourseUpdateWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTeachersDataInput!
}

input CourseUpdateWithWhereUniqueWithoutTermInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutTermDataInput!
}

input CourseUpsertWithoutSessionsInput {
  update: CourseUpdateWithoutSessionsDataInput!
  create: CourseCreateWithoutSessionsInput!
}

input CourseUpsertWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutStudentsDataInput!
  create: CourseCreateWithoutStudentsInput!
}

input CourseUpsertWithWhereUniqueWithoutTeachersInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTeachersDataInput!
  create: CourseCreateWithoutTeachersInput!
}

input CourseUpsertWithWhereUniqueWithoutTermInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutTermDataInput!
  create: CourseCreateWithoutTermInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  students_every: UserWhereInput
  students_some: UserWhereInput
  students_none: UserWhereInput
  teachers_every: UserWhereInput
  teachers_some: UserWhereInput
  teachers_none: UserWhereInput
  term: TermWhereInput
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  sessions_every: SessionWhereInput
  sessions_some: SessionWhereInput
  sessions_none: SessionWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
  code: String
}

scalar DateTime

scalar Long

type Mutation {
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(where: AnswerWhereUniqueInput!, create: AnswerCreateInput!, update: AnswerUpdateInput!): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createResponse(data: ResponseCreateInput!): Response!
  updateResponse(data: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response
  upsertResponse(where: ResponseWhereUniqueInput!, create: ResponseCreateInput!, update: ResponseUpdateInput!): Response!
  deleteResponse(where: ResponseWhereUniqueInput!): Response
  deleteManyResponses(where: ResponseWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createTerm(data: TermCreateInput!): Term!
  updateTerm(data: TermUpdateInput!, where: TermWhereUniqueInput!): Term
  updateManyTerms(data: TermUpdateManyMutationInput!, where: TermWhereInput): BatchPayload!
  upsertTerm(where: TermWhereUniqueInput!, create: TermCreateInput!, update: TermUpdateInput!): Term!
  deleteTerm(where: TermWhereUniqueInput!): Term
  deleteManyTerms(where: TermWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer]!
  answersConnection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnswerConnection!
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  response(where: ResponseWhereUniqueInput!): Response
  responses(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Response]!
  responsesConnection(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResponseConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  term(where: TermWhereUniqueInput!): Term
  terms(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Term]!
  termsConnection(where: TermWhereInput, orderBy: TermOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TermConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  text: String!
  order: Int!
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
  responses(where: ResponseWhereInput, orderBy: ResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Response!]
  session: Session!
  asked: DateTime
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  text: String!
  order: Int!
  answers: AnswerCreateManyWithoutQuestionInput
  responses: ResponseCreateManyWithoutQuestionInput
  session: SessionCreateOneWithoutQuestionsInput!
  asked: DateTime
}

input QuestionCreateManyWithoutSessionInput {
  create: [QuestionCreateWithoutSessionInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateOneWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateOneWithoutResponsesInput {
  create: QuestionCreateWithoutResponsesInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateWithoutAnswersInput {
  id: ID
  text: String!
  order: Int!
  responses: ResponseCreateManyWithoutQuestionInput
  session: SessionCreateOneWithoutQuestionsInput!
  asked: DateTime
}

input QuestionCreateWithoutResponsesInput {
  id: ID
  text: String!
  order: Int!
  answers: AnswerCreateManyWithoutQuestionInput
  session: SessionCreateOneWithoutQuestionsInput!
  asked: DateTime
}

input QuestionCreateWithoutSessionInput {
  id: ID
  text: String!
  order: Int!
  answers: AnswerCreateManyWithoutQuestionInput
  responses: ResponseCreateManyWithoutQuestionInput
  asked: DateTime
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  order_ASC
  order_DESC
  asked_ASC
  asked_DESC
}

type QuestionPreviousValues {
  id: ID!
  text: String!
  order: Int!
  asked: DateTime
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  asked: DateTime
  asked_not: DateTime
  asked_in: [DateTime!]
  asked_not_in: [DateTime!]
  asked_lt: DateTime
  asked_lte: DateTime
  asked_gt: DateTime
  asked_gte: DateTime
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

input QuestionUpdateInput {
  text: String
  order: Int
  answers: AnswerUpdateManyWithoutQuestionInput
  responses: ResponseUpdateManyWithoutQuestionInput
  session: SessionUpdateOneRequiredWithoutQuestionsInput
  asked: DateTime
}

input QuestionUpdateManyDataInput {
  text: String
  order: Int
  asked: DateTime
}

input QuestionUpdateManyMutationInput {
  text: String
  order: Int
  asked: DateTime
}

input QuestionUpdateManyWithoutSessionInput {
  create: [QuestionCreateWithoutSessionInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateOneRequiredWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  update: QuestionUpdateWithoutAnswersDataInput
  upsert: QuestionUpsertWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionUpdateOneRequiredWithoutResponsesInput {
  create: QuestionCreateWithoutResponsesInput
  update: QuestionUpdateWithoutResponsesDataInput
  upsert: QuestionUpsertWithoutResponsesInput
  connect: QuestionWhereUniqueInput
}

input QuestionUpdateWithoutAnswersDataInput {
  text: String
  order: Int
  responses: ResponseUpdateManyWithoutQuestionInput
  session: SessionUpdateOneRequiredWithoutQuestionsInput
  asked: DateTime
}

input QuestionUpdateWithoutResponsesDataInput {
  text: String
  order: Int
  answers: AnswerUpdateManyWithoutQuestionInput
  session: SessionUpdateOneRequiredWithoutQuestionsInput
  asked: DateTime
}

input QuestionUpdateWithoutSessionDataInput {
  text: String
  order: Int
  answers: AnswerUpdateManyWithoutQuestionInput
  responses: ResponseUpdateManyWithoutQuestionInput
  asked: DateTime
}

input QuestionUpdateWithWhereUniqueWithoutSessionInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutSessionDataInput!
}

input QuestionUpsertWithoutAnswersInput {
  update: QuestionUpdateWithoutAnswersDataInput!
  create: QuestionCreateWithoutAnswersInput!
}

input QuestionUpsertWithoutResponsesInput {
  update: QuestionUpdateWithoutResponsesDataInput!
  create: QuestionCreateWithoutResponsesInput!
}

input QuestionUpsertWithWhereUniqueWithoutSessionInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutSessionDataInput!
  create: QuestionCreateWithoutSessionInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  responses_every: ResponseWhereInput
  responses_some: ResponseWhereInput
  responses_none: ResponseWhereInput
  session: SessionWhereInput
  asked: DateTime
  asked_not: DateTime
  asked_in: [DateTime!]
  asked_not_in: [DateTime!]
  asked_lt: DateTime
  asked_lte: DateTime
  asked_gt: DateTime
  asked_gte: DateTime
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

type Response {
  id: ID!
  student: User!
  question: Question!
  answer: Answer!
  session: Session!
  createdAt: DateTime!
}

type ResponseConnection {
  pageInfo: PageInfo!
  edges: [ResponseEdge]!
  aggregate: AggregateResponse!
}

input ResponseCreateInput {
  id: ID
  student: UserCreateOneInput!
  question: QuestionCreateOneWithoutResponsesInput!
  answer: AnswerCreateOneWithoutResponsesInput!
  session: SessionCreateOneInput!
}

input ResponseCreateManyWithoutAnswerInput {
  create: [ResponseCreateWithoutAnswerInput!]
  connect: [ResponseWhereUniqueInput!]
}

input ResponseCreateManyWithoutQuestionInput {
  create: [ResponseCreateWithoutQuestionInput!]
  connect: [ResponseWhereUniqueInput!]
}

input ResponseCreateWithoutAnswerInput {
  id: ID
  student: UserCreateOneInput!
  question: QuestionCreateOneWithoutResponsesInput!
  session: SessionCreateOneInput!
}

input ResponseCreateWithoutQuestionInput {
  id: ID
  student: UserCreateOneInput!
  answer: AnswerCreateOneWithoutResponsesInput!
  session: SessionCreateOneInput!
}

type ResponseEdge {
  node: Response!
  cursor: String!
}

enum ResponseOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type ResponsePreviousValues {
  id: ID!
  createdAt: DateTime!
}

input ResponseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ResponseScalarWhereInput!]
  OR: [ResponseScalarWhereInput!]
  NOT: [ResponseScalarWhereInput!]
}

type ResponseSubscriptionPayload {
  mutation: MutationType!
  node: Response
  updatedFields: [String!]
  previousValues: ResponsePreviousValues
}

input ResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResponseWhereInput
  AND: [ResponseSubscriptionWhereInput!]
  OR: [ResponseSubscriptionWhereInput!]
  NOT: [ResponseSubscriptionWhereInput!]
}

input ResponseUpdateInput {
  student: UserUpdateOneRequiredInput
  question: QuestionUpdateOneRequiredWithoutResponsesInput
  answer: AnswerUpdateOneRequiredWithoutResponsesInput
  session: SessionUpdateOneRequiredInput
}

input ResponseUpdateManyWithoutAnswerInput {
  create: [ResponseCreateWithoutAnswerInput!]
  delete: [ResponseWhereUniqueInput!]
  connect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  disconnect: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutAnswerInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutAnswerInput!]
  deleteMany: [ResponseScalarWhereInput!]
}

input ResponseUpdateManyWithoutQuestionInput {
  create: [ResponseCreateWithoutQuestionInput!]
  delete: [ResponseWhereUniqueInput!]
  connect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  disconnect: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutQuestionInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutQuestionInput!]
  deleteMany: [ResponseScalarWhereInput!]
}

input ResponseUpdateWithoutAnswerDataInput {
  student: UserUpdateOneRequiredInput
  question: QuestionUpdateOneRequiredWithoutResponsesInput
  session: SessionUpdateOneRequiredInput
}

input ResponseUpdateWithoutQuestionDataInput {
  student: UserUpdateOneRequiredInput
  answer: AnswerUpdateOneRequiredWithoutResponsesInput
  session: SessionUpdateOneRequiredInput
}

input ResponseUpdateWithWhereUniqueWithoutAnswerInput {
  where: ResponseWhereUniqueInput!
  data: ResponseUpdateWithoutAnswerDataInput!
}

input ResponseUpdateWithWhereUniqueWithoutQuestionInput {
  where: ResponseWhereUniqueInput!
  data: ResponseUpdateWithoutQuestionDataInput!
}

input ResponseUpsertWithWhereUniqueWithoutAnswerInput {
  where: ResponseWhereUniqueInput!
  update: ResponseUpdateWithoutAnswerDataInput!
  create: ResponseCreateWithoutAnswerInput!
}

input ResponseUpsertWithWhereUniqueWithoutQuestionInput {
  where: ResponseWhereUniqueInput!
  update: ResponseUpdateWithoutQuestionDataInput!
  create: ResponseCreateWithoutQuestionInput!
}

input ResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: UserWhereInput
  question: QuestionWhereInput
  answer: AnswerWhereInput
  session: SessionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  NOT: [ResponseWhereInput!]
}

input ResponseWhereUniqueInput {
  id: ID
}

enum Role {
  Student
  Teacher
}

type Session {
  id: ID!
  startsAt: DateTime!
  endsAt: DateTime!
  course: Course!
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question!]
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  startsAt: DateTime!
  endsAt: DateTime!
  course: CourseCreateOneWithoutSessionsInput!
  questions: QuestionCreateManyWithoutSessionInput
}

input SessionCreateManyWithoutCourseInput {
  create: [SessionCreateWithoutCourseInput!]
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateOneInput {
  create: SessionCreateInput
  connect: SessionWhereUniqueInput
}

input SessionCreateOneWithoutQuestionsInput {
  create: SessionCreateWithoutQuestionsInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutCourseInput {
  id: ID
  startsAt: DateTime!
  endsAt: DateTime!
  questions: QuestionCreateManyWithoutSessionInput
}

input SessionCreateWithoutQuestionsInput {
  id: ID
  startsAt: DateTime!
  endsAt: DateTime!
  course: CourseCreateOneWithoutSessionsInput!
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  startsAt_ASC
  startsAt_DESC
  endsAt_ASC
  endsAt_DESC
}

type SessionPreviousValues {
  id: ID!
  startsAt: DateTime!
  endsAt: DateTime!
}

input SessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateDataInput {
  startsAt: DateTime
  endsAt: DateTime
  course: CourseUpdateOneRequiredWithoutSessionsInput
  questions: QuestionUpdateManyWithoutSessionInput
}

input SessionUpdateInput {
  startsAt: DateTime
  endsAt: DateTime
  course: CourseUpdateOneRequiredWithoutSessionsInput
  questions: QuestionUpdateManyWithoutSessionInput
}

input SessionUpdateManyDataInput {
  startsAt: DateTime
  endsAt: DateTime
}

input SessionUpdateManyMutationInput {
  startsAt: DateTime
  endsAt: DateTime
}

input SessionUpdateManyWithoutCourseInput {
  create: [SessionCreateWithoutCourseInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutCourseInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutCourseInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionUpdateOneRequiredInput {
  create: SessionCreateInput
  update: SessionUpdateDataInput
  upsert: SessionUpsertNestedInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateOneRequiredWithoutQuestionsInput {
  create: SessionCreateWithoutQuestionsInput
  update: SessionUpdateWithoutQuestionsDataInput
  upsert: SessionUpsertWithoutQuestionsInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateWithoutCourseDataInput {
  startsAt: DateTime
  endsAt: DateTime
  questions: QuestionUpdateManyWithoutSessionInput
}

input SessionUpdateWithoutQuestionsDataInput {
  startsAt: DateTime
  endsAt: DateTime
  course: CourseUpdateOneRequiredWithoutSessionsInput
}

input SessionUpdateWithWhereUniqueWithoutCourseInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutCourseDataInput!
}

input SessionUpsertNestedInput {
  update: SessionUpdateDataInput!
  create: SessionCreateInput!
}

input SessionUpsertWithoutQuestionsInput {
  update: SessionUpdateWithoutQuestionsDataInput!
  create: SessionCreateWithoutQuestionsInput!
}

input SessionUpsertWithWhereUniqueWithoutCourseInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutCourseDataInput!
  create: SessionCreateWithoutCourseInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  course: CourseWhereInput
  questions_every: QuestionWhereInput
  questions_some: QuestionWhereInput
  questions_none: QuestionWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  response(where: ResponseSubscriptionWhereInput): ResponseSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  term(where: TermSubscriptionWhereInput): TermSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Term {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  name: String!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type TermConnection {
  pageInfo: PageInfo!
  edges: [TermEdge]!
  aggregate: AggregateTerm!
}

input TermCreateInput {
  id: ID
  startDate: DateTime!
  endDate: DateTime!
  name: String!
  courses: CourseCreateManyWithoutTermInput
}

input TermCreateOneWithoutCoursesInput {
  create: TermCreateWithoutCoursesInput
  connect: TermWhereUniqueInput
}

input TermCreateWithoutCoursesInput {
  id: ID
  startDate: DateTime!
  endDate: DateTime!
  name: String!
}

type TermEdge {
  node: Term!
  cursor: String!
}

enum TermOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  name_ASC
  name_DESC
}

type TermPreviousValues {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  name: String!
}

type TermSubscriptionPayload {
  mutation: MutationType!
  node: Term
  updatedFields: [String!]
  previousValues: TermPreviousValues
}

input TermSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TermWhereInput
  AND: [TermSubscriptionWhereInput!]
  OR: [TermSubscriptionWhereInput!]
  NOT: [TermSubscriptionWhereInput!]
}

input TermUpdateInput {
  startDate: DateTime
  endDate: DateTime
  name: String
  courses: CourseUpdateManyWithoutTermInput
}

input TermUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
  name: String
}

input TermUpdateOneRequiredWithoutCoursesInput {
  create: TermCreateWithoutCoursesInput
  update: TermUpdateWithoutCoursesDataInput
  upsert: TermUpsertWithoutCoursesInput
  connect: TermWhereUniqueInput
}

input TermUpdateWithoutCoursesDataInput {
  startDate: DateTime
  endDate: DateTime
  name: String
}

input TermUpsertWithoutCoursesInput {
  update: TermUpdateWithoutCoursesDataInput!
  create: TermCreateWithoutCoursesInput!
}

input TermWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [TermWhereInput!]
  OR: [TermWhereInput!]
  NOT: [TermWhereInput!]
}

input TermWhereUniqueInput {
  id: ID
  name: String
}

type User {
  id: ID!
  username: String!
  name: String!
  password: String!
  coursesAttending(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  coursesTeaching(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  role: Role!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesAttending: CourseCreateManyWithoutStudentsInput
  coursesTeaching: CourseCreateManyWithoutTeachersInput
  role: Role
}

input UserCreateManyWithoutCoursesAttendingInput {
  create: [UserCreateWithoutCoursesAttendingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutCoursesTeachingInput {
  create: [UserCreateWithoutCoursesTeachingInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCoursesAttendingInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesTeaching: CourseCreateManyWithoutTeachersInput
  role: Role
}

input UserCreateWithoutCoursesTeachingInput {
  id: ID
  username: String!
  name: String!
  password: String!
  coursesAttending: CourseCreateManyWithoutStudentsInput
  role: Role
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  name: String!
  password: String!
  role: Role!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateManyDataInput {
  username: String
  name: String
  password: String
  role: Role
}

input UserUpdateManyMutationInput {
  username: String
  name: String
  password: String
  role: Role
}

input UserUpdateManyWithoutCoursesAttendingInput {
  create: [UserCreateWithoutCoursesAttendingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCoursesAttendingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCoursesAttendingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutCoursesTeachingInput {
  create: [UserCreateWithoutCoursesTeachingInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCoursesTeachingInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCoursesTeachingInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCoursesAttendingDataInput {
  username: String
  name: String
  password: String
  coursesTeaching: CourseUpdateManyWithoutTeachersInput
  role: Role
}

input UserUpdateWithoutCoursesTeachingDataInput {
  username: String
  name: String
  password: String
  coursesAttending: CourseUpdateManyWithoutStudentsInput
  role: Role
}

input UserUpdateWithWhereUniqueWithoutCoursesAttendingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCoursesAttendingDataInput!
}

input UserUpdateWithWhereUniqueWithoutCoursesTeachingInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCoursesTeachingDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutCoursesAttendingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCoursesAttendingDataInput!
  create: UserCreateWithoutCoursesAttendingInput!
}

input UserUpsertWithWhereUniqueWithoutCoursesTeachingInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCoursesTeachingDataInput!
  create: UserCreateWithoutCoursesTeachingInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  coursesAttending_every: CourseWhereInput
  coursesAttending_some: CourseWhereInput
  coursesAttending_none: CourseWhereInput
  coursesTeaching_every: CourseWhereInput
  coursesTeaching_some: CourseWhereInput
  coursesTeaching_none: CourseWhereInput
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  username: String
}
`
      }
    